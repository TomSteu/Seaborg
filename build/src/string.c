/* string.c generated by valac 0.36.6, the Vala compiler
 * generated from string.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))



gboolean seaborg_check_input_packet (const gchar* _str);


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	if ((*((gchar*) self)) == '\0') {
		_tmp1_ = TRUE;
	} else {
		const gchar* _tmp2_;
		_tmp2_ = old;
		_tmp1_ = (*((gchar*) _tmp2_)) == '\0';
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		_tmp3_ = old;
		_tmp4_ = replacement;
		_tmp0_ = g_strcmp0 (_tmp3_, _tmp4_) == 0;
	}
	if (_tmp0_) {
		gchar* _tmp5_;
		_tmp5_ = g_strdup (self);
		result = _tmp5_;
		return result;
	}
	{
		GRegex* regex = NULL;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		GRegex* _tmp9_;
		GRegex* _tmp10_;
		gchar* _tmp11_ = NULL;
		GRegex* _tmp12_;
		const gchar* _tmp13_;
		gchar* _tmp14_;
		gchar* _tmp15_;
		_tmp6_ = old;
		_tmp7_ = g_regex_escape_string (_tmp6_, -1);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_regex_new (_tmp8_, 0, 0, &_inner_error_);
		_tmp10_ = _tmp9_;
		_g_free0 (_tmp8_);
		regex = _tmp10_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch12_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp12_ = regex;
		_tmp13_ = replacement;
		_tmp14_ = g_regex_replace_literal (_tmp12_, self, (gssize) -1, 0, _tmp13_, 0, &_inner_error_);
		_tmp11_ = _tmp14_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch12_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp15_ = _tmp11_;
		_tmp11_ = NULL;
		result = _tmp15_;
		_g_free0 (_tmp11_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally12;
	__catch12_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally12:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


gboolean seaborg_check_input_packet (const gchar* _str) {
	gboolean result = FALSE;
	gchar* str = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gint _tmp9_;
	gint _tmp10_;
	const gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gint _tmp14_;
	gint _tmp15_;
	gboolean _tmp16_;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* _tmp19_;
	gint _tmp20_;
	gint _tmp21_;
	const gchar* _tmp22_;
	gchar* _tmp23_;
	gchar* _tmp24_;
	gint _tmp25_;
	gint _tmp26_;
	gboolean _tmp27_;
	const gchar* _tmp28_;
	gchar* _tmp29_;
	gchar* _tmp30_;
	gint _tmp31_;
	gint _tmp32_;
	const gchar* _tmp33_;
	gchar* _tmp34_;
	gchar* _tmp35_;
	gint _tmp36_;
	gint _tmp37_;
	gboolean _tmp38_;
	g_return_val_if_fail (_str != NULL, FALSE);
	_tmp0_ = _str;
	_tmp1_ = string_replace (_tmp0_, " ", "");
	_tmp2_ = _tmp1_;
	_tmp3_ = string_replace (_tmp2_, "\n", "");
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	str = _tmp4_;
	_tmp5_ = str;
	if (g_strcmp0 (_tmp5_, "") == 0) {
		result = FALSE;
		_g_free0 (str);
		return result;
	}
	_tmp6_ = str;
	_tmp7_ = string_replace (_tmp6_, "[", "");
	_tmp8_ = _tmp7_;
	_tmp9_ = strlen (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = str;
	_tmp12_ = string_replace (_tmp11_, "]", "");
	_tmp13_ = _tmp12_;
	_tmp14_ = strlen (_tmp13_);
	_tmp15_ = _tmp14_;
	_tmp16_ = _tmp10_ != _tmp15_;
	_g_free0 (_tmp13_);
	_g_free0 (_tmp8_);
	if (_tmp16_) {
		result = FALSE;
		_g_free0 (str);
		return result;
	}
	_tmp17_ = str;
	_tmp18_ = string_replace (_tmp17_, "(", "");
	_tmp19_ = _tmp18_;
	_tmp20_ = strlen (_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = str;
	_tmp23_ = string_replace (_tmp22_, ")", "");
	_tmp24_ = _tmp23_;
	_tmp25_ = strlen (_tmp24_);
	_tmp26_ = _tmp25_;
	_tmp27_ = _tmp21_ != _tmp26_;
	_g_free0 (_tmp24_);
	_g_free0 (_tmp19_);
	if (_tmp27_) {
		result = FALSE;
		_g_free0 (str);
		return result;
	}
	_tmp28_ = str;
	_tmp29_ = string_replace (_tmp28_, "{", "");
	_tmp30_ = _tmp29_;
	_tmp31_ = strlen (_tmp30_);
	_tmp32_ = _tmp31_;
	_tmp33_ = str;
	_tmp34_ = string_replace (_tmp33_, "}", "");
	_tmp35_ = _tmp34_;
	_tmp36_ = strlen (_tmp35_);
	_tmp37_ = _tmp36_;
	_tmp38_ = _tmp32_ != _tmp37_;
	_g_free0 (_tmp35_);
	_g_free0 (_tmp30_);
	if (_tmp38_) {
		result = FALSE;
		_g_free0 (str);
		return result;
	}
	result = TRUE;
	_g_free0 (str);
	return result;
}



